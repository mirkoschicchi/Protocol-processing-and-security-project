\chapter{Project implementation}
% Presentation of project implementation:
% functional diagrams,
% solutions used in the implementation,
% what were the most difficult/interesting parts of the implementation,
% why and how were they implemented (describe any innovative ideas and solutions you included; include code snippets as example if necessary)
In this chapter we will take a closer look at the project implementation.
We will start from with the base infrastructure, continuing with layer 2 up to layer 4 and the BGP messages.
At the end we will explain our T-BGP and hybrid model implementation.\newline
In every section we will describe also the limitations and workarounds that we made to reduce the workload.
Note that thanks to these simplifactions, we have been able to finish the project in six weeks maintaining a very high outcome quality.

\section{Simulator infrastructure}

\section{Layer 2}\label{layer2}


\section{Layer 3}\label{layer3}
For what concerns the Network Layer we first created the IPv6 header following the RFC 2460 \cite{rfc2460}.\newline
To be sure that the implementation was correct we created several unit tests to check that the IP packet was parsed correctly.
Moreover, we tried to exchange messages using Wireshark and we noticed that everything was correct.\newline
Then, to simplify the implementation we get rid of the traffic class and the flow label, which are both set to 0.
Note that we do not need them for the BGP implementation itself.
\par About the routing, we initiate the simulation using a YAML document and from that, we initialize the local static routes.\newline
Once the system is running, the routing tables are updated by the routers through the BGP messages.
The path to delivering a packet is based on the prefix match, where we consider the length of the prefix as learnt in the lectures.\newline
In case the prefix is equal, we calculate a second parameter.
It can be the BGP metric whether it is set, or the result of our formula, which takes the AS\_PATH length multiplied by 100 and divides the result by the neighbour trust.
Therefore, the more we trust the next-hop, the smaller will be the calculated parameter and the higher will be the probability that route will be chosen.

\section{Layer 4}\label{layer4}
About the Transport Layer, we decided to implement the TCP header following the RFC 793 \cite{rfc793}.
Also, in this case, we used some default values like the Urgent Pointer, the Options and the relative Padding since we do not need them for this application.\newline
One fundamental limitation is that our TCP implementation is message-based since it was not the main goal of the project and it was a lot easier.
Therefore, there is not data buffer and it can be considered like a UDP protocol but with the TCP header.
Moreover, we did not implement any error handling or retransmission technique.\newline
Nevertheless, we implemented the 3WHS to establish the connection and the FIN based messages to close it.

\section{BGP Messages}\label{BGPMex}
The BGP implementation follows quite specifically the RFC 4271 specification, which define four different kind of messages.
In the next paragraphs there will be a brief recap of required fields for KEEPALIVE, OPEN and NOTIFICATION messages. It's noteworthy to spend more time explaining the implementation of the UPDATE message, which is not trivial as the others due to the taken design decision of using IPv6 rather then the default IPv4.

Each message need to integrate an header, composed by three simple fields:
\begin{itemize}
    \item \texttt{Marker} (16 bytes): each bit is set to 1;
    \item \texttt{Length} (2 bytes): number of bytes of the message, this header included;
    \item \texttt{Type} (1 byte): specify which of the 4 messages is following the header.
\end{itemize}

\subsection{OPEN message}
The OPEN message is the one used to enstablish a connection need to be sent by both parties of the connection.
The message is composed by the following fields:
\begin{itemize}
    \item \texttt{Version} (1 byte): the protocol version number, in this project it is 4;
    \item \texttt{My Autonomous System} (2 bytes): identifier number of the sender;
    \item \texttt{Hold Time} (2 bytes): proposal of Hold Time interval;
    \item \texttt{BGP Identifier} (4 bytes);
    \item \texttt{Optional Parameters Length} (1 byte);
    \item \texttt{Optional Parameters} (variable length).
\end{itemize}


\subsection{KEEPALIVE message}
This message is used when a well-formatted OPEN message is received and need to be sent regularly to avoid the expiration of the Hold Timer. The suggested interval is a third of the Hold Timer. In this project, the Hold Timer expires after 90 seconds of no received KEEPALIVE, which is sent every 30 seconds. No extra fields are included, therefore the 19 byte message header is the sole content of this message.


\subsection{NOTIFICATION message}
When an error is detected, a NOTIFICATION message is sent. Three are the needed fields for this message:
\begin{itemize}
    \item \texttt{Error code} (1 byte);
    \item \texttt{Error subcode} (1 byte);
    \item \texttt{Data} (variable length).
\end{itemize}
Immediatly after the message, the connection is closed.

\subsection{UPDATE message}
As anticipated before, this message required more effort to be implemented because of the requirement to be complient with IPv6.
Therefore, the message is still based on the RFC 4271 \cite{rfc4271}, but apply necessarly take into account some extra path attributes described in the RFC 1812 \cite{rfc1812} specification.
Specified fields from RFC 4271 are:
\begin{itemize}
    \item \texttt{Withdrawn Routes Length} (2 bytes);
    \item \texttt{Withdrawn Routes} (variable);
    \item \texttt{Total Path Attribute Length} (2 bytes);
    \item \texttt{Path Attributes} (variable);
    \item \texttt{Network Layer Reachability Information} (variable).
\end{itemize}
In the standard implementation, \texttt{Withdrawn routes} and \texttt{network layer reachability information} need to be specified as IPv4 addresses in the relative fields of the message itself. Instead, the \texttt{Path attributes} field need to be fullfilled with at least 3 sub-fields which are \texttt{origin}, \texttt{next hop} and \texttt{as path}.
RFC 1812 permit to include two additional sub-fields to \texttt{path attributes}, indicating \texttt{withdrawn routes} and \texttt{network layer reachability information} in a IPv6 format.
This means that:
\begin{itemize}
    \item The \texttt{withdrawn routes length} can take value 0;
    \item Consequently, the \texttt{withdrawn routes} can be leaved empty;
    \item In the same way, also \texttt{network layer reachability information} won't be present anymore.
\end{itemize}
In turn, two additional subfields are specified:
\begin{itemize}
    \item \texttt{MP\_REACH\_NLRI}, where network layer reachability information is specified together with the \texttt{next hop}.
    \item \texttt{MP\_UNREACH\_NLRI}, containing the withdrawn routes.
\end{itemize}
